"use client";

import { useCallback, useRef } from 'react';

/**
 * Options for long press detection
 */
export interface LongPressOptions {
  /**
   * Callback function called when long press is detected
   */
  onLongPress: (event: React.TouchEvent | React.MouseEvent) => void;

  /**
   * Optional callback function called for regular click (if not a long press)
   */
  onClick?: (event: React.TouchEvent | React.MouseEvent) => void;

  /**
   * Delay in milliseconds before long press is triggered (default: 500ms)
   */
  delay?: number;
}

/**
 * Return value from useLongPress hook
 */
export interface LongPressHandlers {
  onTouchStart: (event: React.TouchEvent) => void;
  onTouchEnd: (event: React.TouchEvent) => void;
  onTouchMove: (event: React.TouchEvent) => void;
  onTouchCancel: (event: React.TouchEvent) => void;
  onMouseDown: (event: React.MouseEvent) => void;
  onMouseUp: (event: React.MouseEvent) => void;
  onMouseLeave: () => void;
}

/**
 * Custom hook for detecting long press gestures
 * Supports both touch and mouse events
 * Provides haptic feedback on mobile devices when long press is detected
 *
 * IMPORTANT: This hook properly handles the touch/mouse event conflict on mobile devices.
 * On touch devices, browsers often fire synthetic mouse events after touch events.
 * We track whether touch events were used and ignore subsequent mouse events to prevent
 * double-triggering of actions.
 *
 * @param options - Configuration options for long press detection
 * @returns Event handlers to attach to elements
 *
 * @example
 * ```tsx
 * const longPress = useLongPress({
 *   onLongPress: (e) => {
 *     // Handle long press (e.g., flag a cell)
 *     handleFlag(row, col);
 *   },
 *   onClick: (e) => {
 *     // Handle regular click (e.g., reveal a cell)
 *     handleReveal(row, col);
 *   },
 *   delay: 500
 * });
 *
 * return (
 *   <div
 *     {...longPress}
 *   >
 *     Cell content
 *   </div>
 * );
 * ```
 */
export function useLongPress({
  onLongPress,
  onClick,
  delay = 500,
}: LongPressOptions): LongPressHandlers {
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const isLongPressRef = useRef(false);
  // Track if we're currently processing a touch interaction to prevent mouse event conflicts
  const isTouchActiveRef = useRef(false);
  // Track the last touch end time to ignore synthetic mouse events
  const lastTouchEndRef = useRef(0);

  const clearTimer = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  }, []);

  const handleTouchStart = useCallback(
    (event: React.TouchEvent) => {
      // Only handle single-finger touch
      if (event.touches.length !== 1) {
        return;
      }

      // Mark that we're in a touch interaction
      isTouchActiveRef.current = true;
      isLongPressRef.current = false;
      clearTimer();

      timerRef.current = setTimeout(() => {
        isLongPressRef.current = true;
        // Provide haptic feedback on mobile devices
        if ('vibrate' in navigator) {
          navigator.vibrate(50);
        }
        onLongPress(event);
      }, delay);
    },
    [onLongPress, delay, clearTimer]
  );

  const handleTouchEnd = useCallback(
    (event: React.TouchEvent) => {
      const wasLongPress = isLongPressRef.current;
      clearTimer();

      // Record when touch ended to ignore synthetic mouse events
      lastTouchEndRef.current = Date.now();

      // Trigger onClick only if it wasn't a long press
      if (!wasLongPress && onClick) {
        onClick(event);
      }

      // Reset states
      isLongPressRef.current = false;
      // Keep isTouchActiveRef true briefly to block synthetic mouse events
      setTimeout(() => {
        isTouchActiveRef.current = false;
      }, 300);
    },
    [onClick, clearTimer]
  );

  const handleTouchMove = useCallback(
    (event: React.TouchEvent) => {
      // Cancel long press if finger moves (user is scrolling, not pressing)
      clearTimer();
      isLongPressRef.current = false;
    },
    [clearTimer]
  );

  const handleTouchCancel = useCallback(
    (event: React.TouchEvent) => {
      clearTimer();
      isLongPressRef.current = false;
      isTouchActiveRef.current = false;
    },
    [clearTimer]
  );

  const handleMouseDown = useCallback(
    (event: React.MouseEvent) => {
      // Ignore mouse events that come right after touch events (synthetic events)
      // These are generated by browsers for compatibility but cause double-triggers
      if (isTouchActiveRef.current || Date.now() - lastTouchEndRef.current < 300) {
        return;
      }

      // For mouse, we don't use long press - desktop users have right-click for flagging
      // Just track that we're in a mouse interaction for the click handler
      isLongPressRef.current = false;
      clearTimer();
    },
    [clearTimer]
  );

  const handleMouseUp = useCallback(
    (event: React.MouseEvent) => {
      // Ignore mouse events that come right after touch events
      if (isTouchActiveRef.current || Date.now() - lastTouchEndRef.current < 300) {
        return;
      }

      clearTimer();

      // For mouse, always trigger onClick (no long press on desktop)
      if (onClick) {
        onClick(event);
      }

      isLongPressRef.current = false;
    },
    [onClick, clearTimer]
  );

  const handleMouseLeave = useCallback(() => {
    clearTimer();
  }, [clearTimer]);

  return {
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchCancel: handleTouchCancel,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onMouseLeave: handleMouseLeave,
  };
}
